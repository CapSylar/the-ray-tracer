#include "defs.h"
#include "factories.h"
#include "matrix_routines.h"
#include "trans_routines.h"
#include "ray.h"
#include "world_view.h"
#include <stdio.h>
#include "patterns.h"
#include <stdlib.h>
#include <time.h>

struct canvas
{
    int row ;
    int col ;

    tuple* mem;

};

#test transparency_refraction
    srand( time(NULL) ) ;

    material mat ;
    def_material ( &mat );
    fail_unless ( float_cmp( mat.transparency , 0 )  , "failed to add transparency to material" ) ;
    fail_unless ( float_cmp ( mat.refractive_index , 1 ) , "failed to add transparency to material" ) ;

    object a = get_glass_sphere() ;
    scale ( 2,2,2 , a.trans ) ;
    a.mat.refractive_index = 1.5f ;
    object b = get_glass_sphere() ;
    translate ( 0,0,-0.25f , b.trans ) ;
    b.mat.refractive_index = 2 ;
    object c = get_glass_sphere() ;
    translate ( 0,0,0.25 , c.trans ) ;
    c.mat.refractive_index = 2.5f ;

    tuple point , direction ;
    point = get_point (0,0,-4);
    direction = get_point(0,0,1) ;
    ray god_ray = get_ray ( &point , &direction ) ;

    inter_collec collec = { 6 } ;
    collec.xs = malloc ( sizeof( intersection ) * 6 ) ;

    collec.xs[0] = ( intersection ) { 2 , a } ;
    collec.xs[1] = ( intersection ) { 2.75f , b } ;
    collec.xs[2] = ( intersection ) { 3.25f , c } ;
    collec.xs[3] = ( intersection ) { 4.75f , b } ;
    collec.xs[4] = ( intersection ) { 5.25f , c } ;
    collec.xs[5] = ( intersection ) { 6 , a } ;

    contact_calc contact ;
    compute_contact ( &god_ray , &collec.xs[0] , &contact, &collec ) ;
    fail_unless ( float_cmp( contact.n1 , 1 ) , "failed to calculate correct refraction index" ) ;
    fail_unless ( float_cmp( contact.n2 , 1.5f ) , "failed to calculate correct refraction index" ) ;

    compute_contact ( &god_ray , &collec.xs[1] , &contact, &collec ) ;
    fail_unless ( float_cmp( contact.n1 , 1.5f ) , "failed to calculate correct refraction index" ) ;
    fail_unless ( float_cmp( contact.n2 , 2 ) , "failed to calculate correct refraction index" ) ;

    compute_contact ( &god_ray , &collec.xs[2] , &contact, &collec ) ;
    fail_unless ( float_cmp( contact.n1 , 2 ) , "failed to calculate correct refraction index" ) ;
    fail_unless ( float_cmp( contact.n2 , 2.5f ) , "failed to calculate correct refraction index" ) ;

    compute_contact ( &god_ray , &collec.xs[3] , &contact, &collec ) ;
    fail_unless ( float_cmp( contact.n1 , 2.5f ) , "failed to calculate correct refraction index" ) ;
    fail_unless ( float_cmp( contact.n2 , 2.5f ) , "failed to calculate correct refraction index" ) ;

    compute_contact ( &god_ray , &collec.xs[4] , &contact, &collec ) ;
    fail_unless ( float_cmp( contact.n1 , 2.5f ) , "failed to calculate correct refraction index" ) ;
    fail_unless ( float_cmp( contact.n2 , 1.5f ) , "failed to calculate correct refraction index" ) ;

    compute_contact ( &god_ray , &collec.xs[5] , &contact, &collec ) ;
    fail_unless ( float_cmp( contact.n1 , 1.5f ) , "failed to calculate correct refraction index" ) ;
    fail_unless ( float_cmp( contact.n2 , 1 ) , "failed to calculate correct refraction index" ) ;

    // test the inner point validity

    point = get_point ( 0,0,-5) ;
    direction = get_vector (0,0,1) ;
    god_ray = get_ray ( &point , &direction );
    translate ( 0,0,1 , a.trans ) ;
    intersection i = { 5 , a } ;
    collec.count = 1;
    collec.xs[0] = i ;

    compute_contact ( &god_ray , &collec.xs[0] , &contact, &collec ) ;
    fail_unless ( contact.inner_point.z > EPS/2 , "failed to compute inner point for refraction") ;

    // test the refracted color of an opaque object

    world hello ;
    init_world ( &hello ) ;
    collec.count = 2 ;
    collec.xs[0] = ( intersection ) { 4 , hello.objects[0] } ;
    collec.xs[1] = ( intersection ) { 6 , hello.objects[0] } ;
    god_ray = get_ray ( &point , &direction ) ;
    compute_contact ( &god_ray , &collec.xs[0] , &contact , &collec ) ;
    tuple got_color = refracted_color( &hello , &contact , 5 ) ;
    tuple black = get_color (0,0,0) ;

    fail_unless ( compare_tuple( &got_color , &black ) , "failed to calculate the correct refracted color" );

    // finding the refracted color under total internal reflection

    hello.objects[0].mat.transparency = 1 ;
    hello.objects[0].mat.refractive_index = 1.5;
    point = get_point (0,0,0.7071) ;
    direction = get_vector( 0,1,0 ) ;
    god_ray = get_ray ( &point , &direction );

    collec.count = 2 ;
    collec.xs[0] = ( intersection ) { -0.7071f , hello.objects[0] } ;
    collec.xs[1] = ( intersection ) { 0.7071f , hello.objects[1] } ;

    compute_contact ( &god_ray , &collec.xs[1] , &contact , &collec );
    got_color = refracted_color (&hello , &contact , 5 ) ;

    fail_unless ( compare_tuple ( &got_color , &black ) , "failed to calculate correct refracted color") ;

    // finding the refracted color

    init_world (&hello);
    object floor = get_plane() ;
    floor.mat.transparency = 0.5f ;
    floor.mat.refractive_index = 1.5f;
    translate( 0 , -1 , 0 , floor.trans ) ;

    add_obj_world ( &hello , &floor ) ;

    object sphere = get_sphere() ;
    sphere.mat.color = get_color(1,0,0) ;
    sphere.mat.ambient = 0.5f ;
    translate ( 0 , -3.5f ,-0.5f , sphere.trans ) ;

    add_obj_world ( &hello , &sphere );

    point = get_point (0,0,-3) ;
    direction = get_vector(0,-0.7071f , 0.7071 );
    god_ray = get_ray(&point , &direction ) ;

    collec.count = 1;
    collec.xs[0] = ( intersection ) { 1.4142f , floor } ;

    compute_contact( &god_ray , &collec.xs[0], &contact , &collec ) ;
    got_color = shade_hit ( &hello , &contact , 1 , 5 ) ;

    tuple should_get = get_color ( 0.936364f , 0.686364f , 0.686364f ) ;

    fail_unless ( compare_tuple(&should_get , &got_color) , "failed to compute correct refracted color") ;


#test fresnel_effect
    object sphere = get_glass_sphere() ;

    tuple point = get_point( 0 , 0 , 0.7071f) ;
    tuple direction = get_vector( 0 , 1 , 0 ) ;
    ray god_ray = get_ray ( &point , &direction ) ;
    inter_collec collec;
    collec.count = 2 ;
    collec.xs = malloc ( sizeof(intersection) * 2 ) ;
    collec.xs[0] = ( intersection ) { -0.7071f , sphere } ;
    collec.xs[1] = ( intersection ) { 0.7071f , sphere } ;
    contact_calc calc ;
    compute_contact( &god_ray , &collec.xs[1] , &calc , &collec ) ;
    float reflec = schlick_approx ( &calc ) ;

    fail_unless ( float_cmp( 1 , reflec ) , "failed to approximate fresnel effect" ) ;

    // determine reflectance of a perpendicular ray

    sphere = get_glass_sphere() ;
    point = get_point (0,0,0) ;
    direction = get_vector(0,1,0) ;
    god_ray = get_ray ( &point , &direction ) ;
    collec.xs[0] = ( intersection ) { -1 , sphere  } ;
    collec.xs[1] = ( intersection ) { 1 , sphere } ;
    compute_contact( &god_ray , &collec.xs[1] , &calc , &collec ) ;
    reflec = schlick_approx ( &calc ) ;

    fail_unless ( float_cmp ( 0.04f , reflec ) , "failed to approximate fresnel effect" ) ;

    // determine the reflectance when n2>n1

    point = get_point (0,0.99f , -2 ) ;
    direction = get_vector (0,0,1);
    god_ray = get_ray( &point , &direction ) ;

    collec.count = 1 ;
    collec.xs[0] = ( intersection ) { 1.8589f , sphere } ;
    compute_contact( &god_ray , &collec.xs[0] , &calc , &collec ) ;
    reflec = schlick_approx ( &calc ) ;

    fail_unless ( float_cmp( 0.48873f , reflec ) , "failed to approximate fresnel effect")  ;

    // final test

    world hello ;
    init_world ( &hello ) ;
    point = get_point ( 0,0,-3 ) ;
    direction = get_vector (0 , -0.7071f , 0.7071f ) ;
    god_ray = get_ray (&point , &direction) ;

    object floor = get_plane() ;
    translate ( 0,-1,0 , floor.trans ) ;
    floor.mat.reflective = 0.5f ;
    floor.mat.transparency = 0.5f ;
    floor.mat.refractive_index = 1.5f ;

    add_obj_world( &hello , &floor ) ;

    object ball = get_sphere();
    ball.mat.color = get_color(1,0,0) ;
    ball.mat.ambient = 0.5f ;
    translate ( 0 , -3.5f , -0.5f , ball.trans ) ;

    add_obj_world ( &hello , &ball );
    collec.count = 1 ;
    collec.xs[0] = ( intersection ) { 1.4142f , floor } ;
    compute_contact( &god_ray , &collec.xs[0] , &calc , &collec ) ;

    tuple color = shade_hit( &hello , &calc , 1 , 5 ) ;
    tuple expected = get_color( 0.933867f , 0.69639f , 0.692379f ) ;

    fail_unless ( compare_tuple ( &expected , &color ) , " failed to approximate fresnel effect") ;

#test cube_intersection

    object cube = get_cube() ;
    tuple point = get_point (5,0.5,0) ;
    tuple direction = get_vector(-1,0,0) ;
    ray god_ray = get_ray ( &point , &direction ) ;

    inter_collec collec = {0} ;

    //case 1
    intersect_cube( &god_ray , cube , &collec ) ;

    fail_unless ( float_cmp( 2 , collec.count ) , "failed to intersect the cube correctly" ) ;
    fail_unless ( float_cmp ( 4 , collec.xs[0].t ) , "failed to intersect the cube correcly " ) ;
    fail_unless ( float_cmp ( 6 , collec.xs[1].t ) , "failed to intersect the cube correcly " ) ;

    destroy_coll( &collec ) ;

    //case 2

    point = get_point (-5,0.5,0) ;
    direction = get_vector(1,0,0) ;
    god_ray = get_ray ( &point , &direction ) ;

    intersect_cube( &god_ray , cube , &collec ) ;

    fail_unless ( float_cmp( 2 , collec.count ) , "failed to intersect the cube correctly" ) ;
    fail_unless ( float_cmp ( 4 , collec.xs[0].t ) , "failed to intersect the cube correcly " ) ;
    fail_unless ( float_cmp ( 6 , collec.xs[1].t ) , "failed to intersect the cube correcly " ) ;

    //case 3

    point = get_point (0.5,5,0) ;
    direction = get_vector(0,-1,0) ;
    god_ray = get_ray ( &point , &direction ) ;

    intersect_cube( &god_ray , cube , &collec ) ;

    fail_unless ( float_cmp( 2 , collec.count ) , "failed to intersect the cube correctly" ) ;
    fail_unless ( float_cmp ( 4 , collec.xs[0].t ) , "failed to intersect the cube correcly " ) ;
    fail_unless ( float_cmp ( 6 , collec.xs[1].t ) , "failed to intersect the cube correcly " ) ;

    //case 4

    point = get_point (0.5,-5,0) ;
    direction = get_vector(0,1,0) ;
    god_ray = get_ray ( &point , &direction ) ;

    intersect_cube( &god_ray , cube , &collec ) ;

    fail_unless ( float_cmp( 2 , collec.count ) , "failed to intersect the cube correctly" ) ;
    fail_unless ( float_cmp ( 4 , collec.xs[0].t ) , "failed to intersect the cube correcly " ) ;
    fail_unless ( float_cmp ( 6 , collec.xs[1].t ) , "failed to intersect the cube correcly " ) ;

    //case 5

    point = get_point (0.5,0,5) ;
    direction = get_vector(0,0,-1) ;
    god_ray = get_ray ( &point , &direction ) ;

    intersect_cube( &god_ray , cube , &collec ) ;

    fail_unless ( float_cmp( 2 , collec.count ) , "failed to intersect the cube correctly" ) ;
    fail_unless ( float_cmp ( 4 , collec.xs[0].t ) , "failed to intersect the cube correcly " ) ;
    fail_unless ( float_cmp ( 6 , collec.xs[1].t ) , "failed to intersect the cube correcly " ) ;

    //case 6

    point = get_point (0.5,0,-5) ;
    direction = get_vector(0,0,1) ;
    god_ray = get_ray ( &point , &direction ) ;

    intersect_cube( &god_ray , cube , &collec ) ;

    fail_unless ( float_cmp( 2 , collec.count ) , "failed to intersect the cube correctly" ) ;
    fail_unless ( float_cmp ( 4 , collec.xs[0].t ) , "failed to intersect the cube correcly " ) ;
    fail_unless ( float_cmp ( 6 , collec.xs[1].t ) , "failed to intersect the cube correcly " ) ;

    //case 7

    point = get_point (0.5,0,5) ;
    direction = get_vector(0,0,-1) ;
    god_ray = get_ray ( &point , &direction ) ;

    intersect_cube( &god_ray , cube , &collec ) ;

    fail_unless ( float_cmp( 2 , collec.count ) , "failed to intersect the cube correctly" ) ;
    fail_unless ( float_cmp ( 4 , collec.xs[0].t ) , "failed to intersect the cube correcly " ) ;
    fail_unless ( float_cmp ( 6 , collec.xs[1].t ) , "failed to intersect the cube correcly " ) ;

    // misses the cube test

    point = get_point (-2,0,0) ;
    direction = get_vector(0.2673f,0.5345f,0.8018f) ;
    god_ray = get_ray ( &point , &direction ) ;

    intersect_cube( &god_ray , cube , &collec ) ;

    fail_unless ( float_cmp( 0 , collec.count ) , "failed to intersect the cube correctly" ) ;

    point = get_point (0,-2,0) ;
    direction = get_vector(0.8018f , 0.2673f , 0.5345f ) ;
    god_ray = get_ray ( &point , &direction ) ;

    intersect_cube( &god_ray , cube , &collec ) ;

    fail_unless ( float_cmp( 0 , collec.count ) , "failed to intersect the cube correctly" ) ;

    point = get_point (0,0,-2) ;
    direction = get_vector(0.5345f , 0.8018f , 0.2673f ) ;
    god_ray = get_ray ( &point , &direction ) ;

    intersect_cube( &god_ray , cube , &collec ) ;

    fail_unless ( float_cmp( 0 , collec.count ) , "failed to intersect the cube correctly" ) ;

    point = get_point (2,0,2) ;
    direction = get_vector(0,0,-1) ;
    god_ray = get_ray ( &point , &direction ) ;

    intersect_cube( &god_ray , cube , &collec ) ;

    fail_unless ( float_cmp( 0 , collec.count ) , "failed to intersect the cube correctly" ) ;

    point = get_point (0,2,2) ;
    direction = get_vector(0,-1,0) ;
    god_ray = get_ray ( &point , &direction ) ;

    intersect_cube( &god_ray , cube , &collec ) ;

    fail_unless ( float_cmp( 0 , collec.count ) , "failed to intersect the cube correctly" ) ;

    point = get_point (2,2,0) ;
    direction = get_vector(-1,0,0) ;
    god_ray = get_ray ( &point , &direction ) ;

    intersect_cube( &god_ray , cube , &collec ) ;

    fail_unless ( float_cmp( 0 , collec.count ) , "failed to intersect the cube correctly" ) ;

    // test normal calculations for the cubes

    point = get_point(1,0.5f,-0.8f) ;
    tuple expected = get_vector(1,0,0);

    tuple got = local_normal( &cube , &point ) ;
    fail_unless( compare_tuple( &expected , &got ) , "failed to calculate correct normal for cube") ;

    point = get_point(-1,-0.2f,0.9f) ;
    expected = get_vector(-1,0,0);

    got = local_normal ( &cube , &point ) ;
    fail_unless ( compare_tuple ( &expected , &got ) , "failed to calculate correct normal for cube" ) ;

    point = get_point(-0.4f,1,-0.1f) ;
    expected = get_vector(0,1,0);

    got = local_normal ( &cube , &point ) ;
    fail_unless ( compare_tuple ( &expected , &got ) , "failed to calculate correct normal for cube" ) ;

    point = get_point(0.4f,0.4f,-1) ;
    expected = get_vector(0,0,-1);

    got = local_normal ( &cube , &point ) ;
    fail_unless ( compare_tuple ( &expected , &got ) , "failed to calculate correct normal for cube" ) ;

    point = get_point(1,1,1) ;
    expected = get_vector(1,0,0);

    got = local_normal ( &cube , &point ) ;
    fail_unless ( compare_tuple ( &expected , &got ) , "failed to calculate correct normal for cube" ) ;

    point = get_point(-1,-1,-1) ;
    expected = get_vector(-1,0,0);

    got = local_normal ( &cube , &point ) ;
    fail_unless ( compare_tuple ( &expected , &got ) , "failed to calculate correct normal for cube" ) ;
